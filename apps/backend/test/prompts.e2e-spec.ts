
import 'reflect-metadata';
import { describe, expect, it, beforeAll, afterAll, beforeEach } from "bun:test";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "../src/app.module";
import { INestApplication } from "@nestjs/common";
import { existsSync, rmSync, readFileSync } from 'fs';
import { join } from 'path';
import { execSync } from "child_process";
import { PrismaService } from '../src/infrastructure/database/prisma.service';

describe("Prompts (E2E)", () => {
    let app: INestApplication;
    let prisma: PrismaService;
    const PORT = 3035; // Distinct port
    const ROOT_DIR = join(import.meta.dir, "../../../");
    
    // Track resources to clean up
    const foldersToDelete: string[] = [];
    const promptIdsToDelete: string[] = [];

    beforeAll(async () => {
        // 1. Setup Test Database (Isolation)
        process.env.NODE_ENV = 'test';
        process.env.DATABASE_URL = 'file:./llmunit-e2e.db';

        // Run migrations
        const schemaPath = join(ROOT_DIR, "apps/backend/prisma/schema.prisma");
        execSync(`bunx prisma migrate deploy --schema ${schemaPath}`, {
          env: { ...process.env, DATABASE_URL: 'file:./llmunit-e2e.db' },
          stdio: 'ignore'
        });

        // 2. Initialize App
        app = await NestFactory.create(AppModule, { 
            logger: ['error', 'warn'],
            abortOnError: false,
        });
        
        prisma = app.get(PrismaService);

        // Ensure clean slate
        await prisma.prompt.deleteMany();
        
        app.enableShutdownHooks();
        await app.init();
        await app.listen(PORT);
    });

    afterAll(async () => {
        // 1. Cleanup Filesystem
        for (const folder of foldersToDelete) {
            if (existsSync(folder)) {
                rmSync(folder, { recursive: true, force: true });
            }
        }

        // 2. Cleanup Database
        if (prisma) {
            await prisma.prompt.deleteMany();
            await prisma.$disconnect();
        }
        
        if (app) {
            await app.close();
        }
    });

    it("POST /api/v1/prompts should create prompt and scaffold files", async () => {
        const timestamp = Date.now();
        const name = `E2E Test Prompt ${timestamp}`;
        const folderName = `e2e_test_prompt_${timestamp}`;
        const testsDir = join(import.meta.dir, '../../../tests', folderName);
        foldersToDelete.push(testsDir);

        const response = await fetch(`http://localhost:${PORT}/api/v1/prompts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                name: name,
                content: 'Initial content',
                description: 'Auto-generated by E2E test'
            })
        });

        expect(response.status).toBe(201);
        const body: any = await response.json();
        
        if (body.id) promptIdsToDelete.push(body.id);

        expect(body).toHaveProperty('id');
        expect(body.name).toBe(name);

        // Verify Filesystem Side Effects
        expect(existsSync(testsDir)).toBe(true);
        expect(existsSync(join(testsDir, 'prompt.md'))).toBe(true);
        expect(existsSync(join(testsDir, 'simple_tests.json'))).toBe(true);
        expect(existsSync(join(testsDir, 'mocks.ts'))).toBe(true);

        // Verify Content
        const promptContent = readFileSync(join(testsDir, 'prompt.md'), 'utf-8');
        expect(promptContent).toContain('Initial content');
    });

    it("POST /api/v1/prompts should create prompt with default content when empty", async () => {
        const timestamp = Date.now();
        const name = `E2E Default Content ${timestamp}`;
        const folderName = `e2e_default_content_${timestamp}`;
        const dir = join(import.meta.dir, '../../../tests', folderName);
        foldersToDelete.push(dir);

        const response = await fetch(`http://localhost:${PORT}/api/v1/prompts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                name: name,
                description: 'Testing default content'
            })
        });

        expect(response.status).toBe(201);
        const body: any = await response.json();
        if (body.id) promptIdsToDelete.push(body.id);
        
        // Verify default content in response
        expect(body.content).toContain('You are a helpful assistant');
        expect(body.content).toContain('# Rules');

        // Verify default content in file
        expect(existsSync(join(dir, 'prompt.md'))).toBe(true);
        const fileContent = readFileSync(join(dir, 'prompt.md'), 'utf-8');
        expect(fileContent).toContain('You are a helpful assistant');
    });

    it("DELETE /api/v1/prompts/:id should delete prompt and filesystem files", async () => {
        // Setup separate prompt for deletion to ensure isolation
        const timestamp = Date.now();
        const name = `E2E Delete Test ${timestamp}`;
        const folderName = `e2e_delete_test_${timestamp}`;
        const dir = join(import.meta.dir, '../../../tests', folderName);
        foldersToDelete.push(dir); // Track just in case deletion fails

        // Create
        const createRes = await fetch(`http://localhost:${PORT}/api/v1/prompts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, description: 'To delete' })
        });
        const created: any = await createRes.json();
        const id = created.id;

        // Verify creation
        expect(existsSync(dir)).toBe(true);

        // Delete
        const response = await fetch(`http://localhost:${PORT}/api/v1/prompts/${id}`, {
            method: 'DELETE',
        });

        expect(response.status).toBe(204);

        // Verify DB deletion (should verify via API or DB check)
        const checkResponse = await fetch(`http://localhost:${PORT}/api/v1/prompts/${id}`);
        expect(checkResponse.status).toBe(404);

        // Verify Filesystem Deletion
        expect(existsSync(dir)).toBe(false);
    });
});
